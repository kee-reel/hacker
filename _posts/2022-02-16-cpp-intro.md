---
title: Введение. Различия между C и C++
published: true
tag: cpp
lang: ru
---

Чтобы программировать на C++ необходимо сперва научиться программировать на C. Почему так?

Это не новый язык, который придётся заново изучать -- C++ является расширением языка C, и всё, что ты изучил в курсе C, тебе пригодится и в C++. Однако, какие-то моменты там теперь можно писать иначе -- я покажу какие.

> Если ты не знаешь C, то ты не сможешь изучить C++. [Начни](/c-ru) с языка C.

Давай вспомним что же ты изучил в курсе C:

* [Ввод/вывод](#io)
* [Переменные и типы данных](#variable)
* [Условия](#condition)
* [Циклы](#loop)
* [Указатели](#pointer)
* [Массивы](#array)
* [Строки](#string)
* [Функции](#function)
* [Структуры](#struct)
* [Файлы](#file)

# Ввод/вывод
{: #io }

Вот пример ввода/вывода на C:

```c
// Подключаем библиотеку стандартного ввода/вывода
#include <stdio.h>
int main()
{
	int x;
	// Используем scanf (подключенный из stdio.h) для ввода
	scanf("%d", &x);
	// Используем printf (подключенный из stdio.h) для вывода
	printf("Value = %d\n", x);
	return 0;
}
```

Точно такую же программу можно написать в C++, и она будет прекрасно работать. Надо, разве что, изменить название библиотеки с `stdio.h` на `cstdio` (добавляем 'c' в начале, убираем ".h" в конце).

Но, такой способ ввода/вывода называется теперь "C style", а мы же хотим быть теперь "C++ style"! Вот как такая же программа будет выглядеть в новом "C++ style":

```cpp
// Подключаем библиотеку потокового ввода/вывода
#include <iostream>
int main()
{
	int x;
	// Используем std::cin (подключенный из iostream) для ввода
	std::cin >> x;
	// Используем std::cout (подключенный из iostream) для вывода
	// В конце выводим std::endl вместо '\n'
	std::cout << "Value = " << x << std::endl;
	return 0;
}
```

### Потоки

Потоки это нововведение C++, которое облегчает работу с вводом/выводом в консоль, файлы и т.д.

* `cin` это поток стандартного ввода -- из него мы можем получать данные, введённые с клавиатуры.

* `cout` -- поток стандартного вывода, который может выводить данные в консоль.

Чтобы получить из потока данные, используют оператор `>>` (стрелочки наружу), а чтобы отправить в поток данные -- `<<` (стрелочки внутрь).

### Пространства имён

Ещё, в примере используется какая-то непонятная конструкция `std::` -- что это?

Представь, что у тебя есть две функции с одинаковым названием, и ты вот ни в какую не хочешь их переименовывать. Что делать?

```c
// Возвращает введённую строку
char* input()
{
// ...
}
// Возвращает введённое число
int input()
{
// ...
}
```

В языке C ты бы ничего не смог бы поделать, а в C++ для разрешения таких ситуаций появляются пространства имён:

```cpp
namespace string_utils
{
	char* input()
	{
	// ...
	}
};
namespace number_utils
{
	int input()
	{
	// ...
	}
};
```

Они позволяют разделить определение переменных, функций и прочего так, чтобы они не конфликтовали друг с другом. Обратиться к функциям из примера можно так:

```cpp
char str = string_utils::input();
int number = number_utils::input();
```

В случае с `cin` и `cout` используется пространство имён std, поэтому они так и записываются: `std::cin`, `std::cout`.

# Переменные и типы данных
{: #variable }

В языке C использовались следующие примитивные типы данных:

* char
* int
* float
* double

В комплекте с модификаторами:

* unsigned -- для беззнаковых
* short -- для сокращённого размера
* long -- для увеличенного размера

### Тип bool

В языке C++ используются такие же типы данных, плюс добавляется новый тип данных -- `bool`:

```cpp
bool value_t = true;
bool value_f = false;
if(value_t)
{
	// ...
}
```

В языке C мы использовали для этих задач `char`, в который записывали `1` или `0`. Теперь у нас есть более подходящий для этого тип данных.

### "Тип" auto

Одним из нововведений C++ является ключевое слово `auto` -- оно позволяет нам не указывать тип переменной, если компилятор может понять его из контекста:

```cpp
#include <iostream>
#include <typeinfo>

int main()
{
	int x = 10;
	auto y = 20;
	auto z = 30.0;
	auto w = 40.0f;
	std::cout << typeid(x).name() << std::endl; // Выведет i -- int
	std::cout << typeid(y).name() << std::endl; // Выведет i -- int
	std::cout << typeid(z).name() << std::endl; // Выведет d -- double
	std::cout << typeid(w).name() << std::endl; // Выведет f -- float
}
```

> Чтобы узнать тип переменной я воспользовался C++ библиотекой typeinfo -- не пугайся, она не используется повсеместно, и здесь она нужна только для демонстрации.

Для простых типов `auto` не очень помогает, но в дальнейшим он позволит нам сократить количество кода (когда будут названия классов).

# Условия
{: #condition }

Условия в C и C++ работают одинаково:

```cpp
int x;
std::cin >> x;
if(x > 0)
{
	std::cout << "+";
}
else if(x < 0)
{
	std::cout << "-";
}
else
{
	std::cout << "=";
}
```

# Циклы
{: #loop }

Циклы в C и C++ работают одинаково:

```cpp
// Цикл for
for(int i = 0; i < 10; i++)
	std::cout << i;
// Цикл while
int i = 0;
while(i < 10)
	std::cout << i++;
// Цикл do while
i = 0;
do {
	std::cout << i++;
} while(i < 10);
```

> Забегая вперёд, for теперь может записываться через двоеточие при итерировании по STL контейнеру:
> ```cpp
> std::vector<int> vs = {1, 2, 3};
> for (int s : vs)
> 	std::cout << s << std::endl;
>```
> Но об этом будем говорить потом.

# Указатели
{: #pointer }

Указатели в C и C++ работают одинаково:

```cpp
int x = 42;

int *p1 = &x; // Сохранит адрес переменной x
p1++; // Переместит указатель на 4 байта вправо
p1 -= 2; // Переместит указатель на 8 байт влево

char *p2 = p1; // Сохранит адрес, который сейчас записан в p1 (4 байта влево от переменной x)
p2 += 4; // Переместит указатель на 4 байта вправо, на первый байт переменной x
std::cout << *p2; // Выведет значение первого байта x
```

Если ты понял что тут написано, то ты понимаешь что такое указатели и как с ними работать.

> Для быстрых и смелых -- в библиотеке STL добавятся "умные" указатели. В реальных проектах никто не работает с "сырыми" указателями, а пользуются "умными". Если хочешь ознакомиться, то [вот](https://www.geeksforgeeks.org/smart-pointers-cpp/).

### nullptr

Из нового -- помнишь `NULL`? Так вот, вместо него давай теперь использовать `nullptr`. Объясняю для чего:

```cpp
int x = NULL;
```

Такой код успешно скомпилируется. `NULL` это нулевой адрес `(void*)0`, который может быть неявно приведён в тип int: `(void*)0` -> `0`.

`nullptr` лишён такого недостатка:

```cpp
int x = nullptr;
```

Такой код не скомпилируется, так как `nullptr` запрещает неявное приведение в любые типы, отличные от указалелей или bool.

Возможность неявного приведения в тип bool нужна для использования в условиях:

```cpp
int *x = nullptr;
if(x)
{
	// Выполнится только если x не равен nullptr
}
```

# Массивы
{: #array }

Массивы в C и C++ работают одинаково:

```cpp
int x[10];
for(int i = 0; i < 10; i++)
	std::cin >> x[i];

int *y = malloc(sizeof(int) * 10);
for(int i = 0; i < 10; i++)
	std::cin >> x[i];
```

# Строки
{: #string }

В C строки были представлены char массивами с нуль-терминатором `'\n'` в конце:

```c
char str[50] = "Hello world!";
```

# Функции
{: #function }
# Структуры
{: #struct }
# Файлы
{: #file }


# [](#header-1)Заключение

Итого, ты узнал что такое:


