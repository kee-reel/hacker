---
title: Python. Первый проект
published: true
tag: python
lang: ru
---

В этой статье я приведу пример задачи на ООП и покажу как её решить. После этого я дам несколько самостоятельных заданий.

# Читаем ТЗ

Представляем ситуацию -- ты пришёл работать в компанию, которая занимается продажей обучающих курсов. До тебя никто не занимался автоматизацией, и все задачи выполнялись вручную.

Директор даёт тебе такое техническое задание:

* Создать сайт, на котором пользователи смогут зарегистрироваться
* Зарегистрированный пользователь может оплатить курс
	* Оплата курса на данном этапе не встроена в сайт, и пользователь напрямую связывается с сотрудником компании
	* Сотрудник компании может зайти на сайт под своим профилем, и отметить какой курс был куплен каким пользователем
* После оплаты пользователь может просматривать материалы курса
	* Курс состоит из N занятий
	* Каждое занятие является произвольной веб-страницей

Кажется сложным, поэтому давай сначала продумаем архитектуру нашей системы.

Вот, я набросал UML диаграмму, на которой отразил архитектуру системы в целом (слева) и архитектуру сервера в частности (справа).

![UML диаграмма](/assets/images/python-courses-uml.png)

> UML (Unified Modeling Language) -- унифицированный язык описания систем программного обеспечения.
> Я рисовал через программу [draw.io](https://github.com/jgraph/drawio-desktop/releases/).

С точки зрения архитектуры всей системы, можно выделить следующие компоненты:

* Пользователь -- будет пользоваться сайтом, чтобы смотреть курсы
* Сотрудник -- будет определять доступ пользователя к курсам
* Администратор -- будет определять кто из пользователей является сотрудником
* Сервер -- содержит всю логику сайта
* База данных -- содержит данные, необходимые пользователям и сотрудникам

С точки зрения архитектуры сервера, можно выделить следующие компоненты:

* Пользователь:
	* Уникальный для каждого пользователя id
	* Имя пользователя
	* Статус сотрудника (да/нет)
	* Список купленных курсов
	* Метод, позволяющий изменить статус сотрудника (будет изменяться администратором сервера)
	* Метод, позволяющий изменить состав купленных курсов (будет изменяться сотрудником)
	* Метод, позволяющий проверить был ли куплен тот или иной курс
* Курс
	* Уникальный для каждого курса id
	* Название курса
	* Веб-страница, на которой размещены занятия
	* Список уникальных id занятий
	* Метод, позволяющий показать пользователю страницу покупки курса
	* Метод, позволяющий показать пользователю страницу курса (если курс куплен)
* Занятие
	* Уникальный для каждого занятия id
	* Название занятия
	* Веб-страница занятия
	* Метод, позволяющий показать пользователю страницу занятия (если курс куплен)

Рисовать диаграммы перед разработкой -- хорошая практика. Рисуя диаграмму, можно сразу примерно понять какие классы необходимо создать и как они будут друг с другом связаны, что потенциально сократит время разработки.

# Начинаем разработку

В нашей программе будут использованы СУБД SQLite ([разбор](https://kee-reel.com/sql-intro-ru)) и веб-фреймворк Flask ([разбор](https://kee-reel.com/python-web-server-ru)).

Я начну с организации базы данных.

# Организуем базу данных

Основываясь на архитектуре сервера можно определить, что нам нужно хранить следующие данные:

* Пользователь:
	* Уникальный для каждого пользователя id
	* Имя пользователя
	* Статус сотрудника (да/нет)
	* Список купленных курсов
* Курс
	* Уникальный для каждого курса id
	* Название курса
	* Веб-страница, на которой размещены занятия
	* Список уникальных id занятий
* Занятие
	* Уникальный для каждого занятия id
	* Название занятия
	* Веб-страница занятия

Переведём это на язык запросов SQL:

* Пользователь

```sql
CREATE TABLE user(
	id INTEGER PRIMARY KEY,
	name TEXT,
	is_employee BOOLEAN
);
```

* Курс

```sql
CREATE TABLE course(
	id INTEGER PRIMARY KEY,
	name TEXT,
	page_file TEXT
);
```

* Занятие

```sql
CREATE TABLE lesson(
	id INTEGER PRIMARY KEY,
	name TEXT,
	page_file TEXT
);
```

Так как в SQL нельзя хранить списки в полях таблицы, мы создадим две дополнительных таблицы, чтобы хранить:

* Связь пользователь-купленный курс

```sql
CREATE TABLE user_to_course(
	user_id INTEGER,
	course_id INTEGER,
	PRIMARY KEY(user_id, course_id)
);
```

* Связь курс-занятие

```sql
CREATE TABLE course_to_lesson(
	course_id INTEGER,
	lesson_id INTEGER,
	PRIMARY KEY(course_id, lesson_id)
);
```

Таким образом, чтобы узнать какие курсы были куплены у пользователя, нужно будет посмотреть на все записи в таблице user\_to\_course, где user\_id равен id пользователя. Вот как будет выглядеть такой запрос на SQL:

```sql
-- 666 это просто какой-то id пользователя
SELECT course_id FROM user_to_course WHERE user_id = 666;
```

Получив курсы, пользователь сможет открыть один из них, и посмотреть какие в курсе есть занятия. Вот как на SQL я вытащу все занятия для курса:

```sql
-- 666 это просто какой-то id курса
SELECT lesson_id FROM course_to_lesson WHERE course_id = 666;
```

По ТЗ не надо реализовывать "админку" для наполнения курсов занятиями, поэтому первоначальное наполнение базы будем делать через SQLiteBrowser.

# Пишем сервер

Начнём с кода, который поднимает простейший веб-сервер на Flask:

```python
from flask import Flask

app = Flask('courses')

@app.route('/')
def test():
    return 'test'

app.run(port=1234)
```

Окей, всё работает. Осталось дело за малым -- дописать всю остальную систему :)

Каждый аспект реализации сервера я вынесу в отдельную статью, где подробно разберу и объясню что и зачем делаю.

* [Регистрация](/python-web-reg-and-auth-ru) -- без неё не будет пользователей, а без пользователей не будет продаж курсов.
* Авторизация -- пользователи могут заходить только под своими профилями (под чужими нельзя).
* ...

...

# [](#header-1)Заключение

Итого, мы изучили:

* Заполню после написания всех статей

Если что -- пиши, я помогу и постараюсь объяснить лучше.

