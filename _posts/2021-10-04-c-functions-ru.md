---
title: C. Циклы
published: false
tag: c
lang: ru
---

Цикл (loop) -- это механизм, позволяющий выполнить множество схожих действий.

В языке си есть три вида циклов:

* for
* while
* do while

# Цикл for

Вот пример определения цикла (выводим все делители числа):

```c
int x;
scanf("%d", &x);
printf("Поиск делителей числа %d\n", x);
for(int div = 2; div < x; div++)
{
    if(x % div == 0)
    {
        printf("%d\n", div);
    }
}
```

> div это просто имя переменной -- я так её назвал потому что div это сокращённая запись слова divisor (делитель). В программированнии часто сокращают названия, чтобы меньше писать -- но тут главное знать меру, а то потом сам не разберёшь что написал.

Давай разберём из чего состоит цикл.

### Создание временной переменной

```c
int div = 2;
```

Этот код выполняется __перед__ стартом цикла -- обычно в нём создаётся временная переменная, которая будет использована внутри цикла.

### Условие завершения

```c
div < x;
```

Этот код исполняется перед каждым исполнением тела цикла, и возвращает __булевое__ значение.

В этом примере временная переменная div сравнивается с введённым числом x.

Допустим, мы ввели число 10 -- условие будет верно до тех пор, пока div меньше 10. В момент, когда выражение в условии вернёт значение ложь -- цикл закончится.

### Инкремент временной переменной

```c
div++
```

Здесь обычно пишется инкремент временной переменной. Благодаря этому коду цикл изменяет значение div после прохода каждого цикла.

### Тело цикла

```c
{
    if(x % div == 0)
    {
        printf("%d\n", div);
    }
}
```

Обычно, здесь пишется код, который как-то использует временные переменные -- здесь это переменная div, которая используется для проверки на делимость.

### Всё вместе

Ещё раз напишу код с циклом и добавлю дополнительные логи (вывод сообщений), чтобы лучше понять что происходит:

```c
int x;
scanf("%d", &x);
printf("Поиск делителей числа %d", x);
for(int div = 2; div < x; div++)
{
    printf("Проход цикла: %d\n", div);
    if(x % div == 0)
    {
        printf("Нашли делитель: %d\n", div);
    }
}
```

Таким образом, последовательность применения выражений внутри определения цикла такова:

1. Создание временной переменной:
```c
int div = 2;
```
Переходим к шагу 2.

2. Проверка условия:
```c
div < x;
```
Если значение равно:
* истина -- переходим к шагу 3
* ложь -- переходим к шагу 5.

3. Исполнение тела цикла:
```c
{
    printf("Проход цикла: %d\n", div);
    if(x % div == 0)
    {
        printf("Нашли делитель: %d\n", div);
    }
}
```
Переходим к шагу 4.

4. Инкремент временной переменной:
```c
div++
```
Переходим к шагу 2.

5. Конец цикла.

Вот что выведет эта программа:

```
Поиск делителей числа 10
Проход цикла: 2
Нашли делитель: 2
Проход цикла: 3
Проход цикла: 4
Проход цикла: 5
Нашли делитель: 5
Проход цикла: 6
Проход цикла: 7
Проход цикла: 8
Проход цикла: 9
```

Видишь, строка "Проход цикла:" заканчивается на 9-ке, потому что когда div становится 10, условие div < x не выполняется, и цикл завершается.

# Цикл while

Если ты разобрался с циклом for, то с while у тебя не возникнет проблем -- он намного легче.

Вот как он выглядит (я описал с его помощью ту же задачу, что и выше):

```c
int x;
scanf("%d", &x);
printf("Поиск делителей числа %d", x);
int div = 2;
while(div < x)
{
    printf("Проход цикла: %d\n", div);
    if(x % div == 0)
    {
        printf("Нашли делитель: %d\n", div);
    }
    div++;
}
```

Здесь нужно описать только условие, которое будет проверяться перед проходом каждого цикла. Создание временной переменной и инкремент я просто перенёс в соответствующие места.

Вывод программы будет таким же.

> Очень важно не забывать про инкремент при использовании цикла while! Я уже и не упомню сколько раз у меня получался бесконечный цикл (условие цикла всегда истинно), из-за отсутствия инкремента переменной -- она оставалась на начальном значении, и цикл бесконечно молотил впустую.

# Цикл do while

Те же яйца, только сбоку -- в цикле while проверка условия производится перед исполнением тела цикла, а в цикле do while -- проверка производится после тела цикла.

```c
int x;
scanf("%d", &x);
printf("Поиск делителей числа %d", x);
int div = 2;

if(div >= x)
{
    return;
}

do
{
    printf("Проход цикла: %d\n", div);
    if(x % div == 0)
    {
        printf("Нашли делитель: %d\n", div);
    }
    div++;
}
while(div < x);
```

Вроде бы ничего особо не изменилось, но я зачем-то добавил проверку:

```c
if(div >= x)
{
    return;
}
```

Объясняю зачем -- из-за того, что условие цикла проверится только после прохождения тела цикла, мне надо убедиться что введённое пользователем число подходит под условие div < x.

Представь что этого дополнительного условия нет -- если пользователь введёт -10:

* Тело цикла начнёт выполняться
* Мы напишем "Проход цикла: 2"
* Мы найдём делитель -10 при dev == 2, и напишем "Нашли делитель: 2"
* И только после этого дойдём до проверки div < x (-10 < 2), которая вернёт ложь

А это уже баг!

> Баг (от агл. bug -- жук) -- это жаргонный термин в программировании, обозначающее ошибку при написании программы, которая привела к нежелательному поведению.
> Есть [версия](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%B0%D1%8F_%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0#%D0%AD%D1%82%D0%B8%D0%BC%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0_%C2%AB%D0%B1%D0%B0%D0%B3%C2%BB), что впервые в отношении программной ошибки это термин применили в 1947 году, когда нашли вполне реального "жука" в реле вычислительной машины:
> ![Первый баг](/assets/images/first-bug.png)

# [](#header-1)Заключение

Итого, ты изучил:

* Цикл for
* Цикл while
* Цикл do while

С помощью циклов можно уже решать довольно сложные задачи -- обходить большие массивы данных (про это будет потом), вычислять приближённые значения математических функций, искать числа с определёнными свойствами (например найти 1000 простых числел) и мнооогое другое.

Если что -- пиши, я помогу и постараюсь объяснить лучше.

Дальше мы рассмотрим то, как можно структурировать твои программы -- функции.
